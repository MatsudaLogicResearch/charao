#!/usr/bin/env python3
# -*- coding: utf-8 -*-
###############################################################################
# This file is part of charao.
#
# Based on OriginalProject (https://github.com/snishizawa/libretto)
# Original copyright (C) 2022-2025 Original Author
# Modified by MATSUDA Masahiro, 2025
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
###############################################################################
# Originally named: myExport.py in OriginalProject
###############################################################################
import argparse, re, os, shutil, subprocess, sys, inspect
from itertools import groupby
import datetime, locale, time

from .myFunc import my_exit, f2s_ceil
from .myLibrarySetting       import MyLibrarySetting        as Mls 
from .myLogicCell            import MyLogicCell             as Mlc
from .myConditionsAndResults import MyConditionsAndResults  as Mcar
#from myExpectCell          import MyExpectCell
from .myExpectCell          import logic_dict              
from .myExpectCell          import code_primitive

def exportFiles(targetCell:Mls, harnessList:list[Mcar]):

  ## remove unuse harness
  harnessList_new=[h for h in harnessList if h.measure_type != "no_type"]
  
  ## refer to  harness
  #targetLib = harnessList_new[0].mls
  #targetCell= harnessList_new[0].mlc
  targetLib = targetCell.mls
  
  ## initialize lib
  if(targetLib.isexport == 0):
    initLib(targetLib)
    exportLib(targetLib)
  
  ## export comb. logic
  if((targetLib.isexport == 1) and (targetCell.isexport == 0)):
    exportHarness(targetCell=targetCell, harnessList=harnessList_new)
    exportVerilog(targetLib, targetCell)

    if len(harnessList_new)>0:
      compressFiles(targetLib, targetCell)
    
## initialize export lib and verilog 
def initLib(targetLib:Mls):
  
  ## initilize dotlib file
  outlines = []
  #with open(targetLib.tmp_file, 'w') as f:
  with open(targetLib.dotlib_name, 'w') as f:
    f.writelines(outlines)
  
  ## initilize verilog file 
  outlines = []
  outlines.append(f'// Verilog model :{targetLib.lib_name}')
  outlines.append(f'// Build Date    :{targetLib.build_date}')
  outlines.append(f'// Build Stamp   :{targetLib.build_stamp}')
  outlines.append(f'`default_nettype wire')
  outlines.append(f'`timescale 1ns/1ps')
  outlines.append(f'')

  
  if targetLib.cell_group == "std":
    outlines.append(f'`ifndef SYNTHESIS')
    outlines.append(f'{code_primitive}')
    outlines.append(f'`endif //SYNTHESIS')
    outlines.append(f'')
  
  with open(targetLib.verilog_name, 'w') as f:
    s = "\n".join(outlines) + "\n"
    f.write(s)
    #f.writelines(outlines)


## export library definition to .lib
def exportLib(targetLib:Mls):

  ### get current time
  #locale.setlocale(locale.LC_TIME, 'en_US.UTF-8')
  #now = datetime.datetime.now()
  #tz = time.tzname[0]
  #now_str = now.strftime(f"%a %b %e %H:%M:%S {tz} %Y")  
  #targetLib.date = now_str;  #-- use in myExportDoc
  
  outlines = []
  ## general settings
  outlines.append(f'/* dotlib file generated by charao; */')
  outlines.append(f'library ({targetLib.lib_name}){{')
  
  outlines.append(f'  delay_model : "{targetLib.delay_model}";')
  outlines.append(f'  date        : "{targetLib.build_date}";')
  outlines.append(f'  revision    : "{targetLib.build_stamp}";')

  outlines.append(f'  capacitive_load_unit (1,{targetLib.capacitance_unit});')
  outlines.append(f'  current_unit : "1{targetLib.current_unit}";')
  outlines.append(f'  leakage_power_unit : "1{targetLib.leakage_power_unit}";')
  outlines.append(f'  pulling_resistance_unit : "1{targetLib.resistance_unit}";')
  outlines.append(f'  time_unit : "1{targetLib.time_unit}";')
  outlines.append(f'  voltage_unit : "1{targetLib.voltage_unit}";')

  outlines.append(f'  voltage_map ("{targetLib.vdd_name}", {targetLib.vdd_voltage});')
  outlines.append(f'  voltage_map ("{targetLib.vss_name}", {targetLib.vss_voltage});')
  #outlines.append(f'  voltage_map (GND , {targetLib.vss_voltage});')
  
  outlines.append(f'  default_cell_leakage_power : 0;')
  outlines.append(f'  default_fanout_load : 1;')
  outlines.append(f'  default_max_transition : 1000;')
  outlines.append(f'  default_input_pin_cap : 0;')
  outlines.append(f'  default_inout_pin_cap : 0;')
  outlines.append(f'  default_leakage_power_density : 0;')
  outlines.append(f'  default_max_fanout : 100;')
  outlines.append(f'  default_output_pin_cap : 0;')
  
  outlines.append(f'  in_place_swap_mode : match_footprint;')

  ## power rails
  if targetLib.vdd2_name:
    outlines.append(f'  power_supply(){{')
    outlines.append(f'    power_rail (CORE_VOLTAGE, {targetLib.vdd_voltage});')
    outlines.append(f'    power_rail (CORE2_VOLTAGE, {targetLib.vdd_voltage});')
    outlines.append(f'    default_power_rail: CORE_VOLTAGE;')
    outlines.append(f'  }}')
  elif  targetLib.vddio_name:
    outlines.append(f'  power_supply(){{')
    outlines.append(f'    power_rail (CORE_VOLTAGE, {targetLib.vdd_voltage});')
    outlines.append(f'    power_rail (IO_VOLTAGE, {targetLib.vddio_voltage});')
    outlines.append(f'    default_power_rail: IO_VOLTAGE;')
    outlines.append(f'  }}')

    
  if targetLib.cell_group == "std":
    outlines.append(f'  nom_process : 1;')
    outlines.append(f'  nom_temperature : "{targetLib.temperature}";')
    outlines.append(f'  nom_voltage : "{targetLib.vdd_voltage}";')
    
    outlines.append(f'  operating_conditions ({targetLib.operating_condition}) {{')
    outlines.append(f'    process : 1;')
    outlines.append(f'    temperature : {targetLib.temperature};')
    outlines.append(f'    voltage : {targetLib.vdd_voltage};')
    
    if targetLib.vdd2_name:
      outlines.append(f'    power_rail : CORE_VOLTAGE, {targetLib.vdd_voltage};')
      
    outlines.append(f'  }}')
    outlines.append(f'  default_operating_conditions : {targetLib.operating_condition};')
    
  else:
    outlines.append(f'  nom_process : 1;')
    outlines.append(f'  nom_temperature : {targetLib.temperature};')
    
    vddio_voltage= targetLib.vddio_voltage if targetLib.vddio_name else targetLib.vdd_voltage
    outlines.append(f'  nom_voltage : {vddio_voltage};')
  
    outlines.append(f'  operating_conditions ({targetLib.operating_condition}) {{')
    outlines.append(f'    process : 1;')
    outlines.append(f'    temperature : {targetLib.temperature};')
    outlines.append(f'    voltage : {vddio_voltage};')
    
    if targetLib.vddio_name:
      outlines.append(f'    power_rail : CORE_VOLTAGE, {targetLib.vdd_voltage};')
      outlines.append(f'    power_rail : IO_VOLTAGE, {targetLib.vddio_voltage};')
    
    outlines.append(f'  }}')
    outlines.append(f'  default_operating_conditions : {targetLib.operating_condition};')

  ## cell_arae
  if targetLib.cell_group == "io":
    outlines.append(f'  define_cell_area(pad_drivers,pad_driver_sites);')
    outlines.append(f'  define_cell_area(bond_pads,pad_slots);')
  
  ## input voltage
  for k,v in targetLib.input_voltages.items():
    outlines.append(f'  input_voltage({k}) {{')
    for kk,vv in v.items():
      outlines.append(f'      {kk} : {vv} ;')
    outlines.append(f'  }}')
    
  ## output voltage
  for k,v in targetLib.output_voltages.items():
    outlines.append(f'  output_voltage({k}) {{')
    for kk,vv in v.items():
      outlines.append(f'      {kk} : {vv} ;')
    outlines.append(f'  }}')
    
  #
  outlines.append(f'  input_threshold_pct_fall : {targetLib.logic_high_to_low_threshold*100};')
  outlines.append(f'  input_threshold_pct_rise : {targetLib.logic_low_to_high_threshold*100};')
  outlines.append(f'  output_threshold_pct_fall : {targetLib.logic_high_to_low_threshold*100};')
  outlines.append(f'  output_threshold_pct_rise : {targetLib.logic_low_to_high_threshold*100};')

  outlines.append(f'  slew_derate_from_library : 1;')
  
  outlines.append(f'  slew_lower_threshold_pct_fall : {targetLib.logic_threshold_low*100};')
  outlines.append(f'  slew_lower_threshold_pct_rise : {targetLib.logic_threshold_low*100};')
  outlines.append(f'  slew_upper_threshold_pct_fall : {targetLib.logic_threshold_high*100};')
  outlines.append(f'  slew_upper_threshold_pct_rise : {targetLib.logic_threshold_high*100};')

  
  ## definition of LUT template
  outlines.extend(targetLib.template_lines["mpw"])
  outlines.extend(targetLib.template_lines["const"])
  outlines.extend(targetLib.template_lines["passive"])
  outlines.extend(targetLib.template_lines["delay"])
  outlines.extend(targetLib.template_lines["delay_c2c"])
  outlines.extend(targetLib.template_lines["delay_c2i"])
  outlines.extend(targetLib.template_lines["delay_i2c"])
  outlines.extend(targetLib.template_lines["delay_i2i"])
  outlines.extend(targetLib.template_lines["power"])
  outlines.extend(targetLib.template_lines["power_c2c"])
  outlines.extend(targetLib.template_lines["power_c2i"])
  outlines.extend(targetLib.template_lines["power_i2c"])
  outlines.extend(targetLib.template_lines["power_i2i"])

  ## voltage
  #outlines.append(f'  input_voltage (default_{targetLib.vdd_name}_{targetLib.vss_name}_input) {{')
  #outlines.append(f'    vil : {targetLib.vss_voltage};')
  #outlines.append(f'    vih : {targetLib.vdd_voltage};')
  #outlines.append(f'    vimin : {targetLib.vss_voltage};')
  #outlines.append(f'    vimax : {targetLib.vdd_voltage};')
  #outlines.append(f'  }}')
  #outlines.append(f'  output_voltage (default_{targetLib.vdd_name}_{targetLib.vss_name}_output) {{')
  #outlines.append(f'    vol : "+str(targetLib.vss_voltage};')
  #outlines.append(f'    voh : "+str(targetLib.vdd_voltage};')
  #outlines.append(f'    vomin : "+str(targetLib.vss_voltage};')
  #outlines.append(f'    vomax : "+str(targetLib.vdd_voltage};')
  #outlines.append(f'  }}')
  
  with open(targetLib.dotlib_name, 'a') as f:
    s = "\n".join(outlines) + "\n"
    f.write(s)
    
  #--
  targetLib.set_exported()


## export harness data to .lib
def exportHarness(targetCell:Mls, harnessList:list[Mcar]):

  ## refer to  harness
  #targetLib = harnessList[0].mls
  #targetCell= harnessList[0].mlc
  targetLib = targetCell.mls

  ##
  sigdigs = targetLib.significant_digits
  
  ## cell infomation ############################################################
  outlines = []
  outlines.append(f'  cell ({targetCell.cell}) {{') ## cell start

  ### rails connection
  for k,v in targetCell.rail_connections.items():
    if v:
      outlines.append(f'    rail_connection({k}, {v});')
  
  ### leakage
  outlines.append(f'    cell_leakage_power : {f2s_ceil(f=targetCell.pleak_cell/targetLib.leakage_power_mag, sigdigs=sigdigs)};')

  h_list_pre = [h for h in harnessList if h.template_kind.startswith(("leakage"))]
  h_list     = sorted(h_list_pre, key=lambda x: (x.timing_when));
    
  if len(h_list) > 0:
    for h in h_list:
      outlines.append(f'    leakage_power() {{')
      #outlines.append(f'      power_level : "CORE_VOLTAGE;"')
      outlines.append(f'      when : "{targetCell.replace_by_portmap(h.timing_when)}";')
      outlines.append(f'      value : {f2s_ceil(f=h.pleak/targetLib.leakage_power_mag,sigdigs=sigdigs)};')
      outlines.append(f'    }}')
 
  
  ### base infomation
  outlines.append(f'    area : {targetCell.area};')
  outlines.append(f'    cell_footprint : "{targetCell.logic}";')

  ### additinal infomation for IO cell
  for k,v in targetCell.cell_infos.items():
    if v:
      outlines.append(f'    {k} : {v};')
    
  ### ff infomation
  if targetCell.isflop:
    outlines.append(f'    ff ({targetCell.replace_by_portmap(targetCell.ff["out"])}){{')
    outlines.append(f'      next_state :"{targetCell.replace_by_portmap(targetCell.ff["next_state"])}";')
    outlines.append(f'      clocked_on :"{targetCell.replace_by_portmap(targetCell.ff["clocked_on"])}";')
    for k in ["clear","preset","clear_preset_var1", "clear_preset_var2"]:
      if k in targetCell.ff.keys():
        outlines.append(f'      {k}      :"{targetCell.replace_by_portmap(targetCell.ff[k])}";')
    #
    outlines.append(f'    }}')
    
  #with open(targetLib.tmp_file, 'a') as f:
  with open(targetLib.dotlib_name, 'a') as f:
    s = "\n".join(outlines) + "\n"
    f.write(s)

  outlines = []
  ### PG infomation
  for port in [p for p in (targetCell.vports ) if p is not None]:
    #-- VDD/VSS/VDD1/VSS1/VDDIO/VSSIO
    pin_name=targetCell.replace_by_portmap(port)        
    outlines.append(f'    pg_pin ({pin_name}){{') ## 
    if port.startswith("vdd"): 
      outlines.append(f'      pg_type : "primary_power";')
    else:
      outlines.append(f'      pg_type : "primary_ground";')

    outlines.append(f'      voltage_name : "{pin_name}";')
    outlines.append(f'      direction : "inout";')

    if port in targetCell.pad_infos.keys():
      for k,v in targetCell.pad_infos[port].items():
        if v:
          outlines.append(f'      {k} : {targetCell.replace_by_portmap(v)};')
          
    outlines.append(f'    }}')
  

  ## outport / ioport ############################################################
  for port in [p for p in (targetCell.outports + targetCell.biports ) if p is not None]:
    
    ##-------------------------------------------------------------------------
    ## pin infomation
    outlines.append(f'    pin ({targetCell.replace_by_portmap(port)}){{') ## pin start

    if port.startswith("b"):
      outlines.append(f'      direction : "inout";')
      #-- for output
      if port in targetCell.functions.keys():  #--- inout port with output
        outlines.append(f'      function : "{targetCell.replace_by_portmap(targetCell.functions[port])}";')

      if port in targetCell.max_load4out.keys():
        outlines.append(f'      max_capacitance : "{f2s_ceil(f=targetCell.max_load4out[port],sigdigs=sigdigs)}";')
        
      #-- for input
      max_transition = targetCell.max_trans4in[port] if (port in targetCell.max_trans4in.keys()) else 3.0
      outlines.append(f'      max_transition : {f2s_ceil(f=max_transition, sigdigs=sigdigs)};')
      max_capacitance = targetCell.cins[port] if ( port in targetCell.cins.keys()) else 3.0
      outlines.append(f'      capacitance : "{f2s_ceil(f=max_capacitance, sigdigs=sigdigs)}";')
        
    else: ##"o"
      outlines.append(f'      direction : "output";')
      outlines.append(f'      function : "{targetCell.replace_by_portmap(targetCell.functions[port])}";')
      
      if port in targetCell.max_load4out.keys():
        outlines.append(f'      max_capacitance : "{f2s_ceil(f=targetCell.max_load4out[port],sigdigs=sigdigs)}";') 

    ###  pad infomation
    if port in targetCell.pad_infos.keys():
      for k,v in targetCell.pad_infos[port].items():
        if v:
          outlines.append(f'      {k} : {targetCell.replace_by_portmap(v)};')

    ###  signal level
    if targetCell.mls.vdd2_name or targetCell.mls.vddio_name:
      voltage = "IO_VOLTAGE" if (port in targetCell.io_voltage) else "CORE2_VOLTAGE" if (port in targetCell.vdd2_voltage) else "CORE_VOLTAGE"

      if port.startswith("b"):
        outlines.append(f'      input_signal_level : {voltage};')
        outlines.append(f'      output_signal_level : {voltage};')
      else:
        outlines.append(f'      output_signal_level : {voltage};')
      
    ###  
    outlines.append(f'      related_power_pin : "{targetLib.vdd_name}";')
    outlines.append(f'      related_ground_pin : "{targetLib.vss_name}";')
    #outlines.append(f'      output_voltage : default_{targetLib.vdd_name}_{targetLib.vss_name}_output;')

    ##-------------------------------------------------------------------------
    ## check timing/power infomation
    h_list_pre = [h for h in harnessList if h.template_kind.startswith(("delay","power")) and (h.target_outport==port)]
    h_list     = sorted(h_list_pre, key=lambda x: (x.target_relport, x.timing_type, x.timing_when, x.direction_prop));
    
    if len(h_list) < 1:
      print(f"[INFO]: no harness result exist for target={port}.")
      outlines.append(f'    }}') ## input pin end
      continue

    h_list_t = [h for h in h_list if (h.template_kind.startswith("delay"))]
    h_list_e = [h for h in h_list if (h.template_kind.startswith("power"))]
      
    ##-------------------------------------------------------------------------
    ## timing(delay)
    sorted_harnessList=sorted(h_list_t, key=lambda x: (x.target_relport, x.timing_type, x.timing_when))
    for (target_relport,timing_type,timing_when),group in groupby(sorted_harnessList, key=lambda x:(x.target_relport, x.timing_type, x.timing_when)):
      group_list=list(group);
      size=len(group_list)
      print(f"  [INFO] group(delay): target={port}, relport={target_relport}, timing_type={timing_type}, timing_when={timing_when} -> {size}")

      size_exp=1 if timing_type in ["clear","preset"] else 2
      if (size != size_exp): ## pair of fall/rise
        print(f"Error: len(group) is not {size_exp}(={size}) @{timing_type}")
        my_exit()

      ## check
      h1 = group_list[0]
      if size > 1:
        h2 = group_list[1]
        
        if (h1.stable_inport_val.keys() != h2.stable_inport_val.keys()) :
          print("Error: stable_inport missmatch in %s . harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.stable_inport_val.keys(), h2.stable_inport_val.keys()));
          my_exit();
          
        if (h1.timing_sense != h2.timing_sense) :
          print("Error: timing_sense missmatch in %s. harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.timing_sense, h2.timing_sense));
          my_exit();

      ## infomation
      outlines.append(f'      timing () {{')
      outlines.append(f'        related_pin : "{targetCell.replace_by_portmap(target_relport)}";')

      #-- when/sense/type
      if h1.timing_when:
        #outlines.append(f'        when  : "{targetCell.replace_by_portmap(h1.timing_when).replace("&"," ")}";')
        #outlines.append(f'        sdf_cond  : "{targetCell.replace_by_portmap(h1.timing_when).replace("&"," ")}";')
        outlines.append(f'        when  : "{targetCell.replace_by_portmap(h1.timing_when)}";')
        outlines.append(f'        sdf_cond  : "{targetCell.replace_by_portmap(h1.timing_when)}";')
        
      outlines.append(f'        timing_sense : "{h1.timing_sense}";')
      outlines.append(f'        timing_type : "{h1.timing_type}";')

        
      ## propagation & transition
      for h in group_list:
        t=h.template
        outlines.append(f'        {h.direction_prop} ({t.kind}_template_{t.grid}) {{')
          
        for lut_line in h.lut["prop"]:
          outlines.append(f'          {lut_line}')
        outlines.append(f'        }}') 

        #
        outlines.append(f'        {h.direction_tran} ({t.kind}_template_{t.grid}) {{')
        for lut_line in h.lut["trans"]:
          outlines.append(f'          {lut_line}')
        outlines.append(f'        }}') 

      ##
      outlines.append(f'      }}') ## timing end

    ##-------------------------------------------------------------------------
    ## energy(power)
    sorted_harnessList=sorted(h_list_e, key=lambda x: (x.target_relport, x.timing_type, x.timing_when))
    for (target_relport,timing_type,timing_when),group in groupby(sorted_harnessList, key=lambda x:(x.target_relport, x.timing_type, x.timing_when)):
      group_list=list(group);
      size=len(group_list)
      print(f"  [INFO] group(power): target={port}, relport={target_relport}, timing_type={timing_type}, timing_when={timing_when} -> {size}")
        
      size_exp=1 if timing_type in ["clear","preset"] else 2
      if size != size_exp:
        print(f"Error: len(group) is not {size_exp}(={size}) @{timing_type}")
        my_exit()
        
      ## check
      h1 = group_list[0]
      if size > 1:
        h2 = group_list[1]
        
        if (h1.stable_inport_val.keys() != h2.stable_inport_val.keys()) :
          print("Error: stable_inport missmatch in %s . harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.stable_inport_val.keys(), h2.stable_inport_val.keys()));
          my_exit();
          
        if (h1.timing_sense != h2.timing_sense) :
          print("Error: timing_sense missmatch in %s. harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.timing_sense, h2.timing_sense));
          my_exit();
          
      #-- infomation
      outlines.append(f'      internal_power () {{')

      #-- power level
      if targetCell.mls.vdd2_name or targetCell.mls.vddio_name:
        voltage = "IO_VOLTAGE" if (port in targetCell.io_voltage) else "CORE2_VOLTAGE" if (port in targetCell.vdd2_voltage) else "CORE_VOLTAGE"
        outlines.append(f'        power_level : "{voltage}";')

      #-- related
      outlines.append(f'        related_pin : "{targetCell.replace_by_portmap(target_relport)}";')

      #-- when
      if h1.timing_when != "":
        outlines.append(f'        when  : "{targetCell.replace_by_portmap(h1.timing_when).replace("&"," ")}";')

      ## rise(fall)
      for h in group_list:
        t = h.template
        outlines.append(f'        {h.direction_power} ({t.kind}_energy_template_{t.grid}) {{')
          
        for lut_line in h.lut["eintl"]:
          outlines.append(f'          {lut_line}')
        outlines.append(f'        }}')
        
      outlines.append(f'      }}') ## port end        
    outlines.append(f'    }}') ## out pin end

  ## end of outport/biport
  #with open(targetLib.tmp_file, 'a') as f:
  with open(targetLib.dotlib_name, 'a') as f:
    s = "\n".join(outlines) + "\n"
    f.write(s)


  ## inport ############################################################
  outlines = []
  for port in [p for p in (targetCell.inports + [targetCell.clock]) if p is not None]:

    ##-------------------------------------------------------------------------
    ## pin infomation
    outlines.append(f'    pin ({targetCell.replace_by_portmap(port)}){{') ## 
    outlines.append(f'      direction : "input";')

    ###  pad infomation
    if port in targetCell.pad_infos.keys():
      for k,v in targetCell.pad_infos[port].items():
        if k != "pn_gate" and v:
          outlines.append(f'      {k} : {targetCell.replace_by_portmap(v)};')

    ####  signal level
    if targetCell.mls.vdd2_name or targetCell.mls.vddio_name:
      voltage = "IO_VOLTAGE" if (port in targetCell.io_voltage) else "CORE2_VOLTAGE" if (port in targetCell.vdd2_voltage) else "CORE_VOLTAGE"
      outlines.append(f'      input_signal_level : {voltage};')
    
    #outlines.append(f'      input_voltage : default_{targetLib.vdd_name}_{targetLib.vss_name}_input;')
    outlines.append(f'      related_power_pin : "{targetLib.vdd_name}";')
    outlines.append(f'      related_ground_pin : "{targetLib.vss_name}";')
      
    max_transition = targetCell.max_trans4in[port] if (port in targetCell.max_trans4in.keys()) else 3.0
    outlines.append(f'      max_transition : {f2s_ceil(f=max_transition, sigdigs=sigdigs)};')
      
    max_capacitance = targetCell.cins[port] if ( port in targetCell.cins.keys()) else 3.0
    outlines.append(f'      capacitance : "{f2s_ceil(f=max_capacitance, sigdigs=sigdigs)}";')
      
    if port == "c0":
      outlines.append(f'      clock : true;')

    if port in targetCell.min_pulse_width_high.keys():
      outlines.append(f'      min_pulse_width_high : {f2s_ceil(f=targetCell.min_pulse_width_high[port], sigdigs=sigdigs)};')
        
    if port in targetCell.min_pulse_width_low.keys():
      outlines.append(f'      min_pulse_width_low : {f2s_ceil(f=targetCell.min_pulse_width_low[port], sigdigs=sigdigs)};')
      
    ##-------------------------------------------------------------------------
    ## check timing/power infomation
    h_list = [h for h in harnessList if (h.template_kind in ["const","passive"]) and (h.target_inport == port)]
    h_list_in = sorted(h_list, key=lambda x: (x.target_relport, x.timing_type, x.timing_when, x.constraint));
      
    if len(h_list_in) < 1:
      print(f"[INFO]: no harness result exist for target={port}.")
      outlines.append(f'    }}') ## input pin end
      continue
      
    h_list_in_c = [h for h in h_list_in if (h.template_kind== "const")]
    h_list_in_p = [h for h in h_list_in if (h.template_kind== "passive")]
      
    ##-------------------------------------------------------------------------
    ## timing(const)
    sorted_harnessList=sorted(h_list_in_c, key=lambda x: (x.target_relport, x.timing_type, x.timing_when))
    for (target_relport,timing_type,timing_when),group in groupby(sorted_harnessList, key=lambda x:(x.target_relport, x.timing_type, x.timing_when)):
      group_list=list(group);
      size=len(group_list)
      print(f"  [INFO] group(const): target={port}, relport={target_relport}, timing_type={timing_type}, timing_when={timing_when} -> {size}")

      size_exp=1 if timing_type in ["removal_rising","removal_falling","recovery_rising","recovery_falling"] else 2
      if size != size_exp: ## pair of fall/rise
        print(f"Error: len(group) is not {size_exp}(={size}) @{timing_type}")
        my_exit()

      ## check
      h1 = group_list[0]
      
      if size > 1:
        h2 = group_list[1]
        
        if (h1.stable_inport_val.keys() != h2.stable_inport_val.keys()) :
          print("Error: stable_inport missmatch in %s . harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.stable_inport_val.keys(), h2.stable_inport_val.keys()));
          my_exit();
          
        if (h1.timing_sense != h2.timing_sense) :
          print("Error: timing_sense missmatch in %s. harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.timing_sense, h2.timing_sense));
          my_exit();

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      outlines.append(f'      timing () {{')
      outlines.append(f'        related_pin : "{targetCell.replace_by_portmap(target_relport)}";')

      #-- when/sense/type
      if h1.timing_when:
        #outlines.append(f'        when  : "{targetCell.replace_by_portmap(h1.timing_when).replace("&"," ")}";')
        #outlines.append(f'        sdf_cond  : "{targetCell.replace_by_portmap(h1.timing_when).replace("&"," ")}";')
        outlines.append(f'        when  : "{targetCell.replace_by_portmap(h1.timing_when)}";')
        outlines.append(f'        sdf_cond  : "{targetCell.replace_by_portmap(h1.timing_when)}";')
        
      outlines.append(f'        timing_type : "{h1.timing_type}";')

      ## constraint
      for h in group_list:
        t=h.template
        outlines.append(f'        {h.constraint } ({t.kind + "_template_" + t.grid }) {{')
          
        for lut_line in h.lut["setup_hold"]:
          outlines.append(f'          {lut_line}')
        outlines.append(f'        }}') 

      outlines.append(f'      }}') ## timing end

    ##-------------------------------------------------------------------------
    ## energy(passive)
    sorted_harnessList=sorted(h_list_in_p, key=lambda x: (x.target_relport, x.timing_type, x.timing_when))
    for (target_relport,timing_type,timing_when),group in groupby(sorted_harnessList, key=lambda x:(x.target_relport, x.timing_type, x.timing_when)):
      group_list=list(group);
      size=len(group_list)
      print(f"  [INFO] group(passive): inport={port}, relport={target_relport}, timing_type={timing_type}, timing_when={timing_when} -> {size}")
        
      ## check
      h1 = group_list[0]
      
      if size > 1:
        h2 = group_list[1]
        
        if (h1.stable_inport_val.keys() != h2.stable_inport_val.keys()) :
          print("Error: stable_inport missmatch in %s . harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.stable_inport_val.keys(), h2.stable_inport_val.keys()));
          my_exit();
          
        if (h1.timing_sense != h2.timing_sense) :
          print("Error: timing_sense missmatch in %s. harness[N]=%s, harness[N+1]=%s." %(targetCell.logic, h1.timing_sense, h2.timing_sense));
          my_exit();
          
      #-- infomation
      outlines.append(f'      internal_power () {{')

      #-- power level
      if targetCell.mls.vdd2_name or targetCell.mls.vddio_name:
        voltage = "IO_VOLTAGE" if (port in targetCell.io_voltage) else "CORE2_VOLTAGE" if (port in targetCell.vdd2_voltage) else "CORE_VOLTAGE"
        outlines.append(f'      power_level : {voltage};')
      
      #-- when
      if h1.timing_when != "":
        outlines.append(f'        when  : "{targetCell.replace_by_portmap(h1.timing_when).replace("&"," ")}";')

      ## rise(fall)
      for h in group_list:
        t = h.template
        outlines.append(f'        {h.passive_power} ({t.kind}_energy_template_{t.grid}) {{')
          
        for lut_line in h.lut["eintl"]:
          outlines.append(f'          {lut_line}')
        outlines.append(f'        }}')

      
      outlines.append(f'      }}') ## port end        
    outlines.append(f'    }}') ## in pin end

  outlines.append(f'  }}') ## cell end

  #with open(targetLib.tmp_file, 'a') as f:
  with open(targetLib.dotlib_name, 'a') as f:
    #f.writelines(outlines)
    s = "\n".join(outlines) + "\n"
    f.write(s)

  ################################
  targetCell.set_exported()


## export library definition to .lib
def exportVerilog(targetLib:Mls, targetCell:Mlc):

  cell_suffix=targetLib.cell_name_suffix
  outlines = []

  #--
  ports_s=targetCell.definition.split(); # .subckt NAND2_1X A B YB VDD VSS VNW VPW
  ports_s.pop(0);                   # NAND2_1X A B YB VDD VSS VNW VPW
  ports_s.pop(0);                   # A B YB VDD VSS VNW VPW
  portlist = "(" + ",".join(ports_s) + ");"
    
  outlines.append(f'`celldefine')
  outlines.append(f'module {targetCell.cell} {portlist}')
  #outlines.append(f'module {targetCell.cell}_{cell_suffix} {portlist}\n')

  ## input/output statement
  for outport in targetCell.rvs_portmap(targetCell.outports):
    outlines.append(f'output {outport};')
      
  for clkport in targetCell.rvs_portmap([targetCell.clock]):
    outlines.append(f'input {clkport};')
      
  for inport in targetCell.rvs_portmap(targetCell.inports):
    outlines.append(f'input {inport};')

  ## inout statement
  for target_biport in targetCell.rvs_portmap(targetCell.biports):
    outlines.append(f'inout {target_biport};')

  ## power statement
  for target_vport in targetCell.rvs_portmap(targetCell.vports):
    outlines.append(f'inout {target_vport};')
    #outlines.append(f'input {target_vport}; //use input instead of inout for Yosys.')

  #===================================================================
  outlines.append(f'`ifndef SYNTHESIS')
    
  #===================================================================
  ## code from myExpectCell
  if targetCell.vcode :
    outlines.append(f'{targetCell.vcode}')
  
  #===================================================================
  ## branch for sequencial cell
  elif(targetCell.isflop):
    ## lr_dff (q, d, cp, cdn, sdn, notifier)  ---- q=o0, d=i0, cp=c0, cdn=r0, sdn=s0
      
    ##---- clock
    if "c0" != targetCell.clock:
      print(f"[ERROR] clock port is not defined.")
      my_exit()
    cp     = targetCell.rvs_portmap(["c0"])[0]
    cp_buf = cp
        
    ##---- d
    if "i0" not in  targetCell.inports:
      print(f"[ERROR] clock port is not defined.")
      my_exit()

    d=targetCell.rvs_portmap(["i0"])[0]
    d_buf = d
        
    ##---- reset
    rst_buf ="rst_buf"
    if "r0" in targetCell.inports:
      rst =targetCell.rvs_portmap(["r0"])[0]
      if "_NR" in targetCell.logic:
        outlines.append(f'buf   ({rst_buf}, {rst});'); #-- reset=active low
      else:
        outlines.append(f'not   ({rst_buf}, {rst});'); #-- reset=active high
    else:
      outlines.append(f'pullup({rst_buf});'); #-- active low on primitive

    ##---- set
    set_buf ="set_buf"
    if "s0" in targetCell.inports:
      set =targetCell.rvs_portmap(["s0"])[0]
      if "_NS" in targetCell.logic:
        outlines.append(f'buf   ({set_buf}, {set});'); #-- set=active low
      else:        
        outlines.append(f'not   ({set_buf}, {set});'); #-- set=active high
    else:
      outlines.append(f'pullup({set_buf});'); #-- active low on primitive

    ##---- q
    q_buf ="q_buf"
    if "o0" in targetCell.outports:
      q =targetCell.rvs_portmap(["o0"])[0]
      outlines.append(f'buf   ({q}, {q_buf});')
    else:
      print(f"[ERROR] output port(o0) is not defined.")
      my_exit()

    ##---- qn
    qn_buf ="qn_buf"
    if "o1" in targetCell.outports:
      qn =targetCell.rvs_portmap(["o1"])[0]
      outlines.append(f'not   ({qn}, {q_buf});')

    ##---- notifier
    outlines.append(f'reg   notifier;')
      
    ##---- instance
    outlines.append(f'lr_dff({q_buf},{d_buf},{cp_buf},{rst_buf},{set_buf},notifier);')
        
  #===================================================================
  ## branch for combinational cell/io cell
  else:
    ## assign statement
    for outport in targetCell.outports:
      outlines.append(f'assign {targetCell.replace_by_portmap(outport)} = {targetCell.replace_by_portmap(targetCell.functions[outport])};')

  #===================================================================
  ## specify

  specify=[exp.specify for exp in logic_dict[targetCell.logic]["expect"] if exp.specify !=""]
  
  if len(specify):
    
    outlines.append(f'');
    outlines.append(f'specify');
    
    for expectationdict in logic_dict[targetCell.logic]["expect"]:
      if expectationdict.specify != "":
        when   =targetCell.replace_by_portmap(expectationdict.tmg_when)
    
        flag_ifnone=False
        if expectationdict.specify.endswith(";;"):
          flag_ifnone=True;
            
        specify=targetCell.replace_by_portmap(expectationdict.specify.replace(";;",";"))
          
        if when != "":
          outlines.append(f'  if ({when}) {specify}');
        else:
          outlines.append(f'  {specify}');
    
        if flag_ifnone:
          outlines.append(f'  ifnone {specify}');
          
    outlines.append(f'endspecify');

  #===================================================================
  outlines.append(f'`endif //SYNTHESIS')
    
  #-------------------------------------------------------------------
  outlines.append(f'endmodule')
  outlines.append(f'`endcelldefine')
  outlines.append(f'')

  with open(targetLib.verilog_name, 'a') as f:
    #f.writelines(outlines)
    s = "\n".join(outlines) + "\n"
    f.write(s)


## compress (Cristiano, 20240514)
def compressFiles(targetLib, targetCell):
  if(targetLib.compress == "true"):
    now = datetime.datetime.now()
    dt_string = now.strftime("%Y/%m/%d %H:%M:%S")
    
    targetLib.print_msg(dt_string+" creating "+targetCell.cell+" directory")
    cmd_str = "mkdir "+targetLib.work_dir+"/"+targetCell.cell 
    subprocess.run(cmd_str, shell=True)  
    targetLib.print_msg(dt_string+" compress "+targetCell.cell+" characterization result")
    
    cmd_str = "mv "+targetLib.work_dir+"/vt*"+targetCell.cell+"* "+targetLib.work_dir+"/"+targetCell.cell 
    subprocess.run(cmd_str, shell=True)
    
    #cmd_str = "tar -zcvf "+targetLib.work_dir+"/"+targetCell.cell+".tgz "+targetLib.work_dir+"/"+targetCell.cell 
    cmd_str = "tar -zcf "+targetLib.work_dir+"/"+targetCell.cell+".tgz "+targetLib.work_dir+"/"+targetCell.cell 
    cmd_str += " && rm -rf " + targetLib.work_dir+"/"+targetCell.cell
    subprocess.run(cmd_str, shell=True)

## export harness data to .lib
def exitFiles(targetLib, num_gen_file):
  try:
    with open(targetLib.dotlib_name, 'a') as out:
      #with open(targetLib.tmp_file, 'r') as infile:
      #  out.write(infile.read())
      out.write(f"\n}}\n")

    #
    print(f"\n--  generation completed!!  ")
    print(f"--  {num_gen_file} cells generated in {targetLib.dotlib_name}.\n")

  except FileNotFoundError as e:
    print(f"[ERROR] no file exist.: {e.filename}")
  except Exception as e:
    print(f"[ERROR] unknown error: {e}")
